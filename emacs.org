* Emacs
** Configuration
*** Window Configuration
   Settings for X Window
#+BEGIN_SRC emacs-lisp
  (setq default-frame-alist
        '((font . "-CTDB-Fira Mono-bold-normal-normal-*-14-*-*-*-m-0-iso10646-1")
          (vertical-scroll-bars . nil)
          (line-spacing . 0)))
#+END_SRC

   Disable Tool bar
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode 0)
#+END_SRC

   Disable Menu bar
#+BEGIN_SRC emacs-lisp
  (menu-bar-mode 0)
#+END_SRC

   Disable Scroll bar
#+BEGIN_SRC emacs-lisp
  (scroll-bar-mode 0)
#+END_SRC

   Disable Blinking cursor
#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode 0)
#+END_SRC

   Don't copy to clipboard using X please.
#+BEGIN_SRC emacs-lisp
  (setq x-select-enable-clipboard nil)
#+END_SRC

*** Info
   Personal Info
#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Kevin W. van Rooijen")
  (setq user-mail-address "kevin.van.rooijen@attichacker.com")
#+END_SRC

*** Misc
   Use y / n instead of yes / no
#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

   Allow upcase-region and downcase-region functions
#+BEGIN_SRC emacs-lisp
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
#+END_SRC

   Scroll all the way to the bottom with C-v
#+BEGIN_SRC emacs-lisp
  (setq scroll-error-top-bottom t)
#+END_SRC

   Show nothing in *scratch* when started
#+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message nil)
#+END_SRC

   Hide startup message
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
#+END_SRC

   Default line wrapping should be 80
#+BEGIN_SRC emacs-lisp
  (setq fill-column 80)
#+END_SRC

   Smooth Scrolling
#+BEGIN_SRC emacs-lisp
  (setq redisplay-dont-pause t
        scroll-margin 1
        scroll-conservatively 10000
        scroll-step 1
        auto-window-vscroll nil)
#+END_SRC

   Let C-v M-v brings back where you were.
#+BEGIN_SRC emacs-lisp
  (setq scroll-preserve-screen-position t)
#+END_SRC

   Don't use tabs
#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

   Emacs temp directory
#+BEGIN_SRC emacs-lisp
  (setq temporary-file-directory "~/.emacs.d/tmp/")

  (unless (file-exists-p "~/.emacs.d/tmp")
    (make-directory "~/.emacs.d/tmp"))
#+END_SRC

   Set default tab width to 4
#+BEGIN_SRC emacs-lisp
  (setq tab-width 4)
#+END_SRC

** Macros
*** Helpers
#+BEGIN_SRC emacs-lisp
  (defmacro add-hook* (mode fn)
    `(add-hook ,mode (lambda () ,fn)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defmacro insert! (value)
    `(insert ,(format "%s" value)))
#+END_SRC

** Packages
*** Setup
#+BEGIN_SRC emacs-lisp
  (require 'package)
  (require 'ert)
  (setq package-enable-at-startup nil)
  (add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/") t)
  (add-to-list 'package-archives '("elpa" . "http://elpa.gnu.org/packages/") t)
  (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/") t)
  (package-initialize)
#+END_SRC

Bootstrap use-package
#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (require 'use-package))
  (require 'bind-key)
#+END_SRC

*** Multiple Cursors
Multiple Cursors currently does not work properly with Evil mode. There is
a different version sort somewhat works, we're using that instead.
This has to be loaded first to use the correct version.
#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :load-path "~/.emacs.d/multiple-cursors.el/"
    :bind* (("M-K" . mc/mark-previous-like-this)
            ("M-J" . mc/mark-next-like-this))
    :bind (:map mc/keymap
                ("<return>" . newline))
    :init
    (unless (file-exists-p "~/.emacs.d/multiple-cursors.el/multiple-cursors.el")
      (shell-command "cd ~/.emacs.d && git submodule init && git submodule update"))
    :config
    (multiple-cursors-mode t))
#+END_SRC

*** Ac Cider
#+BEGIN_SRC emacs-lisp
  (use-package ac-cider
    :ensure t)
#+END_SRC

*** Ace Jump Mode
#+BEGIN_SRC emacs-lisp
  (use-package ace-jump-mode
    :ensure t)
#+END_SRC

*** Aggressive Indent
#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :ensure t
    :config
    (add-hook 'scheme-mode-hook 'aggressive-indent-mode)
    (add-hook 'emacs-lisp-mode-hook 'aggressive-indent-mode)
    (add-hook 'clojure-mode-hook 'aggressive-indent-mode)
    (add-hook 'racket-mode-hook 'aggressive-indent-mode))
#+END_SRC

*** Alchemist
#+BEGIN_SRC emacs-lisp
  (use-package alchemist
    :ensure t
    :bind (:map alchemist-mode-map
                ("M-N" . mc/mark-next-like-this)
                ("M-P" . mc/mark-previous-like-this)
                ("M-n" . alchemist-goto-jump-to-next-def-symbol)
                ("M-p" . alchemist-goto-jump-to-previous-def-symbol))
    :init
    (setq alchemist-hooks-compile-on-save nil
          alchemist-hooks-test-on-save nil)
    (add-hook 'elixir-mode-hook 'alchemist-mode))
#+END_SRC

*** Anzu
#+BEGIN_SRC emacs-lisp
  (use-package anzu
    :ensure t
    :init
    (global-anzu-mode))
#+END_SRC

*** Auto Complete
#+BEGIN_SRC emacs-lisp
  (use-package auto-complete
    :init
    (setq ac-auto-show-menu 0.3
          ac-candidate-limit 15
          ac-delay 0.3)
    :config
    (set-face-attribute 'ac-candidate-face nil :inherit 'company-tooltip-common)
    (set-face-attribute 'ac-completion-face nil :inherit 'company-preview-common :background nil :foreground nil)
    (set-face-attribute 'ac-selection-face nil :inherit 'company-tooltip-common-selection))
#+END_SRC

*** Back Button
#+BEGIN_SRC emacs-lisp
  (use-package back-button
    :ensure t
    :init
    (back-button-mode 1))
#+END_SRC

*** Bind Key
#+BEGIN_SRC emacs-lisp
  (use-package bind-key
    :ensure t
    :bind* (("C-c C-o" . switch-to-minibuffer)
            ("C-SPC" . attic-main/body)
            ("M-u" . redo)
            ("C-S-V" . x-clipboard-yank)
            ("C-S-C" . clipboard-kill-ring-save)
            ("C-x C-2" . split-window-below)
            ("C-x C-3" . split-window-right)
            ("C-x C-4" . delete-window)
            ("C-x C-8" . fill-paragraph)
            ("C-x C-k" . kill-this-buffer)
            ("M-+" . align-regexp)
            ("M-C" . capitalize-previous-word)
            ("M-i" . tab-to-tab-stop-line-or-region)
            ("M-I" . tab-to-tab-stop-line-or-region-backward)
            ([f1] . get-current-buffer-major-mode)
            ([f3] . describe-key))
    :config
    (global-unset-key "\C-x\C-z")
    (global-unset-key "\C-z"))
#+END_SRC

*** Cargo
#+BEGIN_SRC emacs-lisp
  (use-package cargo
    :ensure t
    :config
    (add-hook 'rust-mode-hook 'cargo-minor-mode)
    (add-hook 'toml-mode-hook 'cargo-minor-mode))
#+END_SRC

*** Cider
#+BEGIN_SRC emacs-lisp
  (use-package cider
    :ensure t
    :init
    (setq cider-auto-jump-to-error nil)
    :config
    (add-hook 'clojure-mode-hook 'cider-mode))
#+END_SRC

*** Clojure Helm
#+BEGIN_SRC emacs-lisp
  (use-package cljr-helm
    :ensure t
    :bind (:map cljr-helm  ("C-c C-l" . cljr-helm)))
#+END_SRC

*** Clojure Mode
#+BEGIN_SRC emacs-lisp
  (use-package clojure-mode
    :ensure t
    :bind (:map clojure-mode-map
                ("C-x C-e" . cider-eval-last-sexp)))
#+END_SRC

*** Clojure Refactor
#+BEGIN_SRC emacs-lisp
  (use-package clj-refactor
    :ensure t
    :bind (:map clojure-mode-map
                ("C-c C-a" . cljr-refactor-all/body))
    :config
    (defhydra cljr-refactor-all (:color blue)
      "[Clojure refactor]"
      ("c"  hydra-cljr-cljr-menu/body "cljr-menu")
      ("o"  hydra-cljr-code-menu/body "code-menu")
      ("h"  hydra-cljr-help-menu/body "help-menu")
      ("n"  hydra-cljr-ns-menu/body "ns-menu")
      ("p"  hydra-cljr-project-menu/body "project-menu")
      ("t"  hydra-cljr-toplevel-form-menu/body "toplevel-form-menu"))
    (cljr-add-keybindings-with-prefix "C-c C-m")
    (add-hook 'clojure-mode-hook #'clj-refactor-mode))
#+END_SRC

*** Comint
#+BEGIN_SRC emacs-lisp
  (use-package comint
    :init
    (setq tramp-default-method "ssh"          ; uses ControlMaster
          comint-scroll-to-bottom-on-input t  ; always insert at the bottom
          comint-scroll-to-bottom-on-output nil ; always add output at the bottom
          comint-scroll-show-maximum-output t ; scroll to show max possible output
          comint-completion-autolist t     ; show completion list when ambiguous
          comint-input-ignoredups t           ; no duplicates in command history
          comint-completion-addsuffix t       ; insert space/slash after file completion
          comint-buffer-maximum-size 20000    ; max length of the buffer in lines
          comint-prompt-read-only nil         ; if this is t, it breaks shell-command
          comint-get-old-input (lambda () "") ; what to run when i press enter on a
                                          ; line above the current prompt
          comint-input-ring-size 5000         ; max shell history size
          protect-buffer-bury-p nil)

    (defun make-my-shell-output-read-only (text)
      "Add to comint-output-filter-functions to make stdout read only in my shells."
      (interactive)
      (if (equal major-mode 'shell-mode)
          (let ((inhibit-read-only t)
                (output-end (process-mark (get-buffer-process (current-buffer)))))
            (put-text-property comint-last-output-start output-end 'read-only t))))
    :config
    (add-hook 'comint-output-filter-functions 'make-my-shell-output-read-only)
    (add-hook 'comint-output-filter-functions 'comint-truncate-buffer))
#+END_SRC

*** Company
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :bind (:map company-active-map
                ("M-f" . company-complete-selection)
                ("<return>" . company-abort-and-newline)
                ("C-m" . company-abort-and-newline)
                ("M-h" . helm-company)
                ("M-j" . yas/expand)
                ("C-n" . company-select-next)
                ("C-p" . company-select-previous))
    :init
    (setq company-idle-delay 0.3
          company-minimum-prefix-length 1)
    (defun company-abort-and-newline ()
      (interactive)
      (company-abort)
      (newline))
    :config
    (add-hook 'alchemist-iex-mode-hook 'company-mode)
    (add-hook 'rust-mode-hook 'company-mode)
    (add-hook 'scheme-mode-hook 'company-mode)
    (add-hook 'erlang-mode-hook 'company-mode)
    (add-hook 'elixir-mode-hook 'company-mode)
    (add-hook 'elm-mode-hook 'company-mode)
    (add-hook 'emacs-lisp-mode-hook 'company-mode)
    (add-to-list 'company-backends 'company-elm))
#+END_SRC

*** Company Racer
#+BEGIN_SRC emacs-lisp
  (use-package company-racer
    :ensure t)
#+END_SRC

*** Compile
#+BEGIN_SRC emacs-lisp
  (use-package compile
    :bind (:map compilation-mode-map
                ("<SPC>" . attic-main/body))
    :init
    ;; Scroll on in the *compilation* buffer
    (setq compilation-scroll-output t))
#+END_SRC

*** CSS Mode
#+BEGIN_SRC emacs-lisp
  (use-package css-mode
    :mode ("\\.less\\'"
           "\\.scss\\'"))
#+END_SRC

*** Dash
#+BEGIN_SRC emacs-lisp
  (use-package dash
    :ensure t)
#+END_SRC

*** Delsel
#+BEGIN_SRC emacs-lisp
  (use-package delsel
    :config
    ;; Delete seleted text when typing
    (delete-selection-mode 1))
#+END_SRC

*** Dired
#+BEGIN_SRC emacs-lisp
  (use-package dired
    :config
    (defun ensure-buffer-name-begins-with-exl ()
      "change buffer name to end with slash"
      (let ((name (buffer-name)))
        (if (not (string-match "/$" name))
            (rename-buffer (concat "!" name) t))))
    (add-hook 'dired-mode-hook 'ensure-buffer-name-begins-with-exl))
#+END_SRC

*** Doc View
#+BEGIN_SRC emacs-lisp
  (use-package doc-view
    :bind (:map doc-view-mode-map
                ("j" . doc-view-next-line-or-next-page)
                ("k" . doc-view-previous-line-or-previous-page)
                ("l" . image-forward-hscroll)
                ("h" . image-backward-hscroll)))
#+END_SRC

*** Dockerfile Mode
#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode
    :ensure t)
#+END_SRC

*** Eldoc
#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :config
    (add-hook 'emacs-lisp-mode-hook 'eldoc-mode))
#+END_SRC

*** Electric Pair
#+BEGIN_SRC emacs-lisp
  (use-package elec-pair
    :init
    (setq electric-pair-pairs
          '((?\" . ?\")
            (?\{ . ?\})))
    :config
    (electric-pair-mode t)
    (add-hook* 'message-mode-hook (electric-pair-mode -1))
    (add-hook* 'clojure-mode-hook (electric-pair-mode -1))
    (add-hook 'prog-mode-hook 'electric-pair-mode))
#+END_SRC

*** Elfeed
#+BEGIN_SRC emacs-lisp
  (use-package elfeed
    :ensure t
    :init
    (setq elfeed-search-filter "@12-months-ago"
          elfeed-feeds
          '("http://feeds.5by5.tv/changelog"
            "http://feeds.twit.tv/floss.xml"
            "http://thecommandline.net/cmdln"
            "http://cloudevangelist.jellycast.com/podcast/feed/123"))
    (defun url-copy-file-to-path (url path)
      (let* ((file-name (car (last (split-string  url "/"))))
             (full-path (expand-file-name file-name path)))
        (unless (file-exists-p full-path)
          (url-copy-file url full-path))
        full-path))
    (defun elfeed-open-in-emms ()
      (interactive)
      (save-excursion
        (goto-char 1)
        (let ((done nil))
          (while (and (re-search-forward ".*mp3$" nil t)
                      (not done))
            (backward-char 1)
            (when (get-text-property (point) 'shr-url)
              (setq kill-ring (cdr kill-ring))
              (let* ((url (string-remove-prefix  "Copied " (shr-copy-url)))
                     (full-path (url-copy-file-to-path url "~/Podcasts/")))
                (emms-play-file full-path)
                (setq done t)))))))
    :config
    (bind-key "j" 'elfeed-open-in-emms elfeed-show-mode-map))
#+END_SRC

*** Elixir Mode
#+BEGIN_SRC emacs-lisp
  (use-package elixir-mode
    :ensure t)
#+END_SRC

*** Elm Mode
#+BEGIN_SRC emacs-lisp
  (use-package elm-mode
    :ensure t
    :config
    (defun elm-reactor ()
      (interactive)
      (async-shell-command "elm-reactor" "*elm-reactor*"))
    (add-hook 'elm-mode-hook #'elm-oracle-setup-completion))
#+END_SRC

*** Elscreen
#+BEGIN_SRC emacs-lisp
  (use-package elscreen
    :ensure t
    :init
    (elscreen-start)
    (setq elscreen-display-screen-number nil
          elscreen-prefix-key nil
          elscreen-tab-display-control nil
          elscreen-tab-display-kill-screen nil)
    (defun elscreen-create-initial-5-screens ()
      (interactive)
      (elscreen-kill-others)
      (elscreen-create) (elscreen-create) (elscreen-create)
      (elscreen-create) (elscreen-create) (elscreen-kill 0)
      (elscreen-goto 1))
    (elscreen-create-initial-5-screens)
    :config
    (defun elscreen-goto-template (num)
      `(defun ,(read  (concat "elscreen-goto-" (number-to-string num))) ()
         ,(concat "Go to elscreen workspace " (number-to-string num) ".")
         (interactive)
         (elscreen-goto ,num)))
    (defmacro elscreen-goto-workspace-list (&rest nums)
      (let ((forms (mapcar 'elscreen-goto-template nums)))
        `(progn ,@forms)))
    (elscreen-goto-workspace-list 1 2 3 4 5))
#+END_SRC

*** Elwm
#+BEGIN_SRC emacs-lisp
  (use-package elwm
    :ensure t)
#+END_SRC

*** Emms
#+BEGIN_SRC emacs-lisp
  (use-package emms
    :ensure t
    :init
    (unless (file-exists-p "~/.emacs.d/emms")
      (make-directory "~/.emacs.d/emms"))
    (setq emms-setup-default-player-list '(emms-player-vlc)
          emms-volume-change-amount 5)
    :config
    (when (and (file-exists-p "~/Music/")
               (> (length (directory-files "~/Music/")) 2))
      (emms-standard)
      (emms-default-players)
      (emms-add-directory-tree "~/Music/")
      (emms-toggle-repeat-playlist)
      (emms-shuffle)
      (emms-playing-time-enable-display)))
#+END_SRC

*** Erc
#+BEGIN_SRC emacs-lisp
  (use-package erc
    :bind (:map erc-mode-map
                ("C-M-m" . erc-send-current-line)
                ("RET" . erc-no-return))
    :init
    (defadvice attic/erc (after attic-ad/attic/erc-after activate)
      (setq erc-password nil))
    (defun attic/erc ()
      (interactive)
      (load "~/.erc.gpg")
      (erc :server "irc.freenode.net"
           :port 6667
           :nick erc-nick
           :password erc-password))
    (defun erc-no-return ()
      (interactive)
      (message "Use C-M-m to send"))
    (setq erc-scrolltobottom-mode 1
          erc-nick "kwrooijen"
          erc-prompt-for-password nil
          erc-ignore-list '("*Flowdock*" "Flowdock" "-Flowdock-")
          erc-hide-list '("JOIN" "PART" "QUIT"))
    :config
    (erc-truncate-mode 1)
    (set-face-attribute 'erc-nick-default-face nil :foreground "#528B8B")
    (add-hook* 'erc-mode-hook (setq-local mode-line-format nil)))
#+END_SRC

*** Erlang
#+BEGIN_SRC emacs-lisp
  (use-package erlang
    :ensure t
    :mode ("\\.app.src\\'"
           "rebar.config")
    :commands erlang-mode
    :init
    (setq inferior-erlang-machine-options '("-sname" "emacs"))
    :config
    (setq-mode-local erlang-mode tab-width 4))
#+END_SRC

*** Etags
#+BEGIN_SRC emacs-lisp
  (use-package etags
    :init
    ;; Ctags location
    (setq tags-file-name "~/.ctags")
    ;; Reread a TAGS table without querying, if it has changed.
    (setq tags-revert-without-query t))
#+END_SRC

*** Evil
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :ensure t
    :bind (:map evil-normal-state-map
                ("C-d" . delete-char)
                ("<SPC>" . attic-main/body)
                ("C-M-P" . evil-paste-pop-or-kill-ring)
                :map evil-visual-state-map
                ("<SPC>" . attic-main/body))
    :bind* (("M-q" . evil-normal-state))
    :init
    (defun evil-paste-pop-or-kill-ring ()
      (interactive)
      (if (or (equal last-command 'evil-paste-after) (equal last-command 'evil-paste-pop))
          (evil-paste-pop 1)
        (helm-show-kill-ring)))
    :config
    (add-hook 'minibuffer-setup-hook #'turn-off-evil-mode)
    (add-hook 'prog-mode-hook #'turn-on-evil-mode)
    (add-hook 'org-mode-hook #'turn-on-evil-mode)
    (add-hook 'gitignore-mode-hook #'turn-on-evil-mode)
    (evil-set-initial-state 'term-mode 'emacs)
    (evil-set-initial-state 'magit-popup-mode 'emacs)
    (evil-set-initial-state 'magit-status-mode 'emacs)
    (defun evil-normal-state-and-save ()
      (interactive)
      (evil-normal-state)
      (save-buffer)))
#+END_SRC

*** Evil Lispy
#+BEGIN_SRC emacs-lisp
  (use-package evil-lispy
    :ensure t
    :config
    (evil-define-key 'normal emacs-lisp-mode-map (kbd "TAB") 'evil-lispy/enter-state-left)
    (evil-define-key 'normal lisp-interaction-mode-map (kbd "TAB") 'evil-lispy/enter-state-left)
    (evil-define-key 'normal scheme-mode-map (kbd "TAB") 'evil-lispy/enter-state-left)
    (evil-define-key 'normal clojure-mode-map (kbd "TAB") 'evil-lispy/enter-state-left)
    (evil-define-key 'normal racket-mode-map (kbd "TAB") 'evil-lispy/enter-state-left))
#+END_SRC

*** Evil Nerd Commenter
#+BEGIN_SRC emacs-lisp
  (use-package evil-nerd-commenter
    :ensure t
    :bind* (("C-/" . evilnc-comment-or-uncomment-lines)))
#+END_SRC

*** Evil Numbers
#+BEGIN_SRC emacs-lisp
  (use-package evil-numbers
    :ensure t
    :bind* (("C-c C-=" . evil-numbers/inc-at-pt)
            ("C-c C--" . evil-numbers/dec-at-pt)))
#+END_SRC

*** Evil Paredit
#+BEGIN_SRC emacs-lisp
  (use-package evil-paredit
    :ensure t
    :config
    (add-hook 'paredit-mode-hook 'evil-paredit-mode))
#+END_SRC

*** Expand Region
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind* (("M-@" . er/expand-region)))
#+END_SRC

*** Fancy Battery
#+BEGIN_SRC emacs-lisp
  (use-package fancy-battery
    :ensure t
    :init
    (fancy-battery-mode))
#+END_SRC

*** Files
#+BEGIN_SRC emacs-lisp
  (use-package files
    :init
    (setq remote-file-name-inhibit-cache nil)
    ;; Make sure the file ends with a newline
    (setq require-final-newline t)
    ;; Backup ~ files in seperate directory
    (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
    ;; No confirmation when creating new buffer
    (setq confirm-nonexistent-file-or-buffer nil))
#+END_SRC

*** Flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck-rust
    :ensure t)
#+END_SRC

*** Flyspell
#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :init
    (add-hook 'org-mode-hook 'flyspell-mode)
    (add-hook 'org-mode-hook 'flyspell-buffer))
#+END_SRC

*** Fringe
#+BEGIN_SRC emacs-lisp
  (use-package fringe
    :config
    (set-fringe-mode '(1 . 0)))
#+END_SRC

*** Geiser
#+BEGIN_SRC emacs-lisp
  (use-package geiser
    :ensure t
    :init
    (setq geiser-popup--no-jump t)
    (defun geiser-eval-next-sexp (print-to-buffer-p)
      "Eval the next sexp in the Geiser REPL.

  With a prefix, print the result of the evaluation to the buffer."
      (interactive "P")
      (let* ((ret (geiser-eval-region (save-excursion (forward-sexp) (point))
                                      (point)
                                      nil
                                      t
                                      print-to-buffer-p))
             (str (geiser-eval--retort-result-str ret (when print-to-buffer-p ""))))
        (when (and print-to-buffer-p (not (string= "" str)))
          (push-mark)
          (insert str))))
    :config
    (defun helm-geiser ()
      (interactive)
      (unless (geiser-doc--manual-available-p)
        (error "No manual available"))
      (let ((symbol (helm :sources (helm-build-sync-source "Geiser"
                                     :candidates (geiser-completion--symbol-list ""))
                          :buffer "*helm Geiser")))
        (geiser-doc--external-help geiser-impl--implementation
                                   symbol
                                   (geiser-eval--get-module)))))
#+END_SRC

*** Gist
#+BEGIN_SRC emacs-lisp
  (use-package gist
    :ensure t
    :init
    (defun send-to-gist (answer)
      (interactive "cSend region to Gist?: (y/n) ")
      (if (equal answer ?\y) (gist-region (region-beginning) (region-end)))))
#+END_SRC

*** Git Gutter Fringe+
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter-fringe+
    :if window-system
    :ensure t
    :config
    (global-git-gutter+-mode t))
#+END_SRC

*** Git Gutter+
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter+
    :if (not window-system)
    :ensure t
    :config
    (global-git-gutter+-mode t))
#+END_SRC

*** Gitignore Mode
#+BEGIN_SRC emacs-lisp
  (use-package gitignore-mode
    :ensure t)
#+END_SRC

*** Grep
#+BEGIN_SRC emacs-lisp
  (use-package grep
    :bind (:map grep-mode-map
                ("n" . next-line)
                ("p" . previous-line)
                ("TAB" . grep-error-preview)
                ("v" . scroll-up-command)
                ("z" . helm-buffers-list))
    :init
    (defun grep-error-preview ()
      (interactive)
      (compile-goto-error)
      (switch-to-buffer-other-window "*grep*")))
#+END_SRC

*** Hackernews
#+BEGIN_SRC emacs-lisp
  (use-package hackernews
    :ensure t)
#+END_SRC

*** Haskell Mode
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :ensure t
    :config
    (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
    (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation))
#+END_SRC

*** Helm
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :ensure t
    :bind* (("M-[" . helm-resume)
            ("M-x" . helm-M-x))
    :bind (:map helm-map
                ("C-b" . nil)
                ("C-f" . nil)
                ("M-b" . nil)
                ("M-f" . forward-word)
                ("M-s" . helm-select-action)
                ("TAB" . helm-execute-persistent-action)
                ("<RET>" . my/helm-exit-minibuffer)
                ("M-?" . helm-help))
    :init
    (setq
     ;; truncate long lines in helm completion
     helm-truncate-lines t
     ;; may be overridden if 'ggrep' is in path (see below)
     helm-grep-default-command "grep -a -d skip %e -n%cH -e %p %f"
     helm-grep-default-recurse-command "grep --exclude-dir=\"dist\" -a -d recurse %e -n%cH -e %p %f"
     ;; do not display invisible candidates
     helm-quick-update t
     ;; be idle for this many seconds, before updating in delayed sources.
     helm-idle-delay 0.01
     ;; be idle for this many seconds, before updating candidate buffer
     helm-input-idle-delay 0.01
     ;; open helm buffer in another window
     helm-split-window-default-side 'other
     ;; limit the number of displayed canidates
     helm-candidate-number-limit 200
     ;; don't use recentf stuff in helm-ff
     helm-ff-file-name-history-use-recentf nil
     ;; fuzzy matching
     helm-buffers-fuzzy-matching t
     helm-semantic-fuzzy-match t
     helm-imenu-fuzzy-match t
     helm-completion-in-region-fuzzy-match t
     helm-echo-input-in-header-line t
     ;; Don't ask to create new file
     helm-ff-newfile-prompt-p nil
     helm-reuse-last-window-split-state t
     helm-ff-transformer-show-only-basename nil
     ;; Split window down
     helm-split-window-in-side-p t
     ;; Split when multiple windows open
     helm-swoop-split-with-multiple-windows t
     ;; Don't show colors in Tramp mode
     helm-ff-tramp-not-fancy t
     ;; Smarter completion for Helm
     helm-ff-smart-completion t
     ;; Helm-dash should use W3m for showing documentation
     helm-dash-browser-func 'eww
     ;; Don't add delay when choosing
     helm-exit-idle-delay 0
     ;; Don't display header
     helm-display-header-line nil
     ;; Set a min / max height of 30% of current buffer
     helm-autoresize-max-height 30
     helm-autoresize-min-height 30
     helm-bookmark-show-location t
     helm-always-two-windows t
     helm-imenu-execute-action-at-once-if-one nil)
    :config
    (use-package helm-files
      :config
      (set-face-attribute 'helm-ff-directory nil
                          :foreground 'unspecified
                          :background 'unspecified
                          :inherit 'dired-directory)
      (set-face-attribute 'helm-ff-file nil
                          :foreground 'unspecified
                          :background 'unspecified
                          :inherit 'default)
      (set-face-attribute 'helm-ff-symlink nil
                          :foreground 'unspecified
                          :background 'unspecified
                          :inherit 'dired-symlink))
    (use-package helm-buffers
      :config
      (set-face-attribute 'helm-buffer-directory nil
                          :foreground 'unspecified
                          :background 'unspecified
                          :inherit 'dired-directory)
      (set-face-attribute 'helm-buffer-file nil
                          :foreground 'unspecified
                          :background 'unspecified
                          :inherit 'default)
      (set-face-attribute 'helm-buffer-process nil
                          :foreground "#cd8500"
                          :background 'unspecified))
    ;; Try to hide source header as much as possible
    (set-face-attribute 'helm-source-header nil :height 0.1 :background "#000"  :foreground "#000")

    ;; Work around for the [Display not ready] error when typing too awesomely fast
    (defun my/helm-exit-minibuffer ()
      (interactive)
      (helm-exit-minibuffer))
    (defhydra helm-like-unite ()
      ("q" nil "Quit" :color blue)
      ("<spc>" helm-toggle-visible-mark "mark")
      ("a" helm-toggle-all-marks "(un)mark all")
      ("v" helm-execute-persistent-action)
      ("g" helm-beginning-of-buffer "top")
      ("h" helm-previous-source)
      ("l" helm-next-source)
      ("G" helm-end-of-buffer "bottom")
      ("j" helm-next-line "down")
      ("J" helm-next-source "down source")
      ("K" helm-prev-source "up source")
      ("k" helm-previous-line "up")
      ("i" nil "cancel"))
    ;; Hide the minibuffer when in Helm mode. We don't need it since we use
    ;; `helm-echo-input-in-header-line t`
    (defun helm-hide-minibuffer-maybe ()
      (when (with-helm-buffer helm-echo-input-in-header-line)
        (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
          (overlay-put ov 'window (selected-window))
          (overlay-put ov 'face (let ((bg-color (face-background 'default nil)))
                                  `(:background ,bg-color :foreground ,bg-color)))
          (setq-local cursor-type nil))))
    (add-hook 'helm-minibuffer-set-up-hook 'helm-hide-minibuffer-maybe))
#+END_SRC

*** Helm Dash
#+BEGIN_SRC emacs-lisp
  (use-package helm-dash
    :ensure t
    :bind* (("C-c C-s C-d" . helm-dash))
    :config
    (setq-mode-local clojure-mode helm-dash-docsets '("Clojure"))
    (setq-mode-local elixir-mode helm-dash-docsets '("Elixir"))
    (setq-mode-local emacs-lisp-mode helm-dash-docsets '("Emacs Lisp"))
    (setq-mode-local erlang-mode helm-dash-docsets '("Erlang"))
    (setq-mode-local haskell-mode helm-dash-docsets '("Haskell"))
    (setq-mode-local ruby-mode helm-dash-docsets '("Ruby"))
    (setq-mode-local rust-mode helm-dash-docsets '("Rust")))
#+END_SRC

*** Helm Descbinds
#+BEGIN_SRC emacs-lisp
  (use-package helm-descbinds
    :ensure t)
#+END_SRC

*** Helm Projectile
#+BEGIN_SRC emacs-lisp
  (use-package helm-projectile
    :ensure t
    :init
    (setq projectile-use-git-grep t)
    :config
    (projectile-global-mode 1))
#+END_SRC

*** Helm Swoop
#+BEGIN_SRC emacs-lisp
  (use-package helm-swoop
    :ensure t
    :bind* (("C-c C-s C-s" . helm-multi-swoop))
    :bind (:map helm-swoop-map
                ("M-e" . helm-swoop-edit)))
#+END_SRC

*** Highlight Defined
#+BEGIN_SRC emacs-lisp
  (use-package hl-defined
    :ensure t
    :init
    (setq hdefd-highlight-type 'functions)
    :config
    (add-hook 'emacs-lisp-mode-hook 'hdefd-highlight-mode)
    (add-hook 'scheme-mode-hook 'hdefd-highlight-mode)
    (add-hook 'clojure-mode-hook 'hdefd-highlight-mode)
    (set-face-attribute 'hdefd-functions nil :foreground nil :inherit 'font-lock-function-name-face))
#+END_SRC

*** Highlight line
#+BEGIN_SRC emacs-lisp
  (use-package hl-line
    :init
    (add-hook 'prog-mode-hook 'hl-line-mode))
#+END_SRC

*** Highlight Numbers
#+BEGIN_SRC emacs-lisp
  (use-package highlight-numbers
    :ensure t
    :config
    (add-hook 'prog-mode-hook 'highlight-numbers-mode))
#+END_SRC

*** Highlight Symbols
#+BEGIN_SRC emacs-lisp
  (use-package highlight-symbol
    :ensure t
    :bind  (:map prog-mode-map
                 ("M-j" . highlight-symbol-next)
                 ("M-k" . highlight-symbol-prev))
    :init
    (setq highlight-symbol-ignore-list
          '("def" "defun" "define" "defmacro"
            "use-package" "defmodule" "do"
            "require" "alias" "use" "let" "="
            "-" "+" "/"))
    (add-hook 'prog-mode-hook 'highlight-symbol-mode)
    (setq highlight-symbol-idle-delay 0))
#+END_SRC

*** Hydra
#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :ensure t
    :config
    (defhydra attic-emms (:color red)
      "EMMS"
      ("a" emms-pause "Pause")
      ("g" emms-playlist-mode-go "Playlist")
      ("n" emms-next "Next")
      ("p" emms-previous "Previous")
      ("]" emms-volume-raise "+")
      ("[" emms-volume-lower "-")
      ("f" emms-seek-forward "f")
      ("b" emms-seek-backward "b")
      ("q" nil "Quit" :color blue)))
#+END_SRC

*** Indy
#+BEGIN_SRC emacs-lisp
  (use-package indy
    :ensure t
    :init
    (setq indy-rules
          '((erlang-mode
             .
             (((indy--prev 'indy--ends-on "->" "fun" "of" "begin") (indy--prev-tab 1))
              ((indy--prev 'indy--ends-on ";") (indy--prev-tab -1))
              ((and (indy--prev 'indy--ends-on "end") (indy--current 'indy--starts-with "end")) (indy--prev-tab -1))
              ((indy--current 'indy--ends-on "end") (indy--prev-tab -1))
              ((and (indy--prev 'indy--ends-on "[") (indy--current 'indy--starts-with "]")) (indy--prev-tab))
              ((and (indy--prev 'indy--ends-on "{") (indy--current 'indy--starts-with "}")) (indy--prev-tab))
              ((and (indy--prev 'indy--ends-on "(") (indy--current 'indy--starts-with ")")) (indy--prev-tab))
              ((indy--current 'indy--starts-with "]" "}" ")") (indy--prev-tab -1))
              ((indy--prev 'indy--ends-on "[" "{" "(") (indy--prev-tab 1))
              ((indy--prev 'indy--ends-on ",") (indy--prev-tab))))))
    :config
    (add-hook 'erlang-mode-hook 'indy-mode))
#+END_SRC

*** Key Chord
#+BEGIN_SRC emacs-lisp
  (use-package key-chord
    :ensure t
    :config
    (add-hook* 'prog-mode-hook (key-chord-mode 1))
    (add-hook* 'isearch-mode-hook (key-chord-mode 1))
    (key-chord-define-global "xs" 'evil-normal-state-and-save))
#+END_SRC

*** Linum
#+BEGIN_SRC emacs-lisp
  (use-package linum
    :init
    (setq linum-format (quote "%3d")
          linum-disabled-modes-list '(mu4e-compose-mode
                                      mu4e-headers-mode
                                      mu4e-main-mode))
    :config
    (set-face-attribute 'linum nil :inherit 'default :background nil))
#+END_SRC

*** Lispy
#+BEGIN_SRC emacs-lisp
  (use-package lispy
    :ensure t
    :bind (:map lispy-mode-map
                ("TAB" . lispy-left-no-mark)
                ("d" . lispy-different)
                ("o" . lispy-other-mode)
                ("f" . lispy-flow)
                ("i" . evil-insert)
                ("e" . attic/lispy--eval)
                ("J" . evil-join))
    :init
    (defun attic/lispy--eval ()
      (interactive)
      (if (equal major-mode 'scheme-mode)
          (geiser-eval-next-sexp nil)
        (special-lispy-eval)))
    :config
    (defun lispy-left-no-mark ()
      (interactive)
      (deactivate-mark)
      (lispy-left 1)))
#+END_SRC

*** Macrostep
#+BEGIN_SRC emacs-lisp
  (use-package macrostep
    :ensure t)
#+END_SRC

*** Magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :init
    (setq magit-last-seen-setup-instructions "1.4.0")
    :config
    (bind-key "g" 'magit-refresh magit-status-mode-map))
#+END_SRC

*** Markdown Mode
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t)
#+END_SRC

*** Mu4e
#+BEGIN_SRC emacs-lisp
  (use-package mu4e
    :load-path "/usr/local/share/emacs/site-lisp/mu4e"
    :bind (:map mu4e-main-mode-map
                :map mu4e-main-mode-map
                ("p" . previous-line)
                ("n" . next-line)
                ("z" . helm-buffers-list)
                ("v" . scroll-up-command)
                :map mu4e-compose-mode-map
                ("M-s" . mml-secure-sign-pgp)
                :map mu4e-headers-mode-map
                ("v" . scroll-up-command)
                :map mu4e-view-mode-map
                ("f" . epa-mail-verify)
                ("v" . scroll-up-command))
    :init
    (setq message-send-mail-function 'smtpmail-send-it
          mu4e-get-mail-command "offlineimap"
          mu4e-maildir (expand-file-name "~/Mail")
          starttls-use-gnutls t
          smtpmail-starttls-credentials '(("mail.hover.com" 587 nil nil))
          smtpmail-default-smtp-server "mail.hover.com"
          smtpmail-smtp-server "mail.hover.com"
          smtpmail-smtp-service 587
          smtpmail-debug-info t
          mu4e-update-interval 60
          message-kill-buffer-on-exit t
          mu4e-hide-index-messages t
          ;; Requires html2text package
          mu4e-html2text-command "html2text -utf8 -width 72"
          mu4e-view-show-images t))
#+END_SRC

*** Mu4e Alert
#+BEGIN_SRC emacs-lisp
  (use-package mu4e-alert
    :ensure t
    :config
    (mu4e-alert-enable-mode-line-display))
#+END_SRC

*** Mu4e Maildirs Extension
#+BEGIN_SRC emacs-lisp
  (use-package mu4e-maildirs-extension
    :ensure t
    :config
    (mu4e-maildirs-extension))
#+END_SRC

*** Org
#+BEGIN_SRC emacs-lisp
  (use-package org
    :bind (:map org-mode-map
                ("C-c e" . org-edit-src-code))
    :init
    (setq org-log-done 'time
          org-capture-templates '()
          org-src-fontify-natively t
          org-ellipsis " ⤵"))
#+END_SRC

*** Org Bullets
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :ensure t
    :init
    (setq org-bullets-bullet-list '("◉"))
    (add-hook 'org-mode-hook 'org-bullets-mode))
#+END_SRC

*** Paredit
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :ensure t
    :bind (:map paredit-mode-map
                ("C-w" . paredit-kill-region)
                ("M-R" . paredit-splice-sexp-killing-backward)
                ("C-c C-r" . paredit-reindent-defun)
                ("M-j" . paredit-join-sexps))
    :config
    (add-hook 'cider-repl-mode-hook 'paredit-mode)
    (add-hook 'clojure-mode-hook 'paredit-mode)
    (add-hook 'elixir-mode-hook 'paredit-mode)
    (add-hook 'geiser-mode-hook 'paredit-mode)
    (add-hook 'racket-mode-hook 'paredit-mode)
    (add-hook 'scheme-mode-hook 'paredit-mode)
    (add-hook 'emacs-lisp-mode-hook 'paredit-mode)
    (add-hook 'lisp-interaction-mode-hook 'paredit-mode))
#+END_SRC

*** Paren
#+BEGIN_SRC emacs-lisp
  (use-package paren
    :config
    (show-paren-mode t))
#+END_SRC

*** Programming Mode
#+BEGIN_SRC emacs-lisp
  (use-package prog-mode
    :init
    (setq prettify-lisp-alist '(("lambda" . 955)))
    (add-hook 'scheme-mode-hook 'prettify-symbols-mode)
    (add-hook 'emacs-lisp-mode-hook 'prettify-symbols-mode)
    (add-hook 'clojure-mode-hook 'prettify-symbols-mode)
    (add-hook 'racket-mode-hook 'prettify-symbols-mode)
    (add-hook* 'scheme-mode-hook (setq-local prettify-symbols-alist prettify-lisp-alist))
    (add-hook* 'emacs-lisp-mode-hook (setq-local prettify-symbols-alist prettify-lisp-alist))
    (add-hook* 'clojure-mode-hook (setq-local prettify-symbols-alist prettify-lisp-alist))
    (add-hook* 'racket-mode-hook (setq-local prettify-symbols-alist prettify-lisp-alist)))
#+END_SRC

*** Racer
#+BEGIN_SRC emacs-lisp
  (use-package racer
    :ensure t
    :init
    (setq racer-cmd "/usr/local/bin/racer"
          racer-rust-src-path "/usr/local/src/rust/src/")
    :config
    (setq-mode-local rust-mode company-backends '(company-racer))
    (add-hook 'rust-mode-hook 'racer-mode)
    (add-hook 'rust-mode-hook 'racer-turn-on-eldoc))
#+END_SRC

*** Racket Mode
#+BEGIN_SRC emacs-lisp
  (use-package racket-mode
    :ensure t)
#+END_SRC

*** Redo+
#+BEGIN_SRC emacs-lisp
  (use-package redo+
    :ensure t
    :bind* (("M-_" . redo)))
#+END_SRC

*** Ruby Mode
#+BEGIN_SRC emacs-lisp
  (use-package ruby-mode
    :mode ("Gemfile$"
           "Rakefile$"
           "\\.gemspec$"
           "\\.rake$"
           "\\.rb$"
           "\\.ru$")
    :init
    (setq ruby-deep-indent-paren nil))
#+END_SRC

*** Rust Mode
#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :ensure t
    :bind (:map rust-mode-map
                ("C-c C-c C-z" . racer-find-definition))
    :config
    (setq-mode-local rust-mode tab-width 4))
#+END_SRC

*** Scheme Mode
#+BEGIN_SRC emacs-lisp
  (use-package scheme-complete
    :ensure t
    :config
    (autoload 'scheme-get-current-symbol-info "scheme-complete" nil t))
#+END_SRC

*** Simple
#+BEGIN_SRC emacs-lisp
  (use-package simple
    :init
    ;; C-u C-SPC will repeat if C-SPC is pressed again
    (setq set-mark-command-repeat-pop t)
    :config
    (setq-mode-local fundamental-mode require-final-newline nil)
    ;; Kill buffer on remote machine
    (defadvice async-shell-command (before attic-ad/async-shell-command activate)
      (when (get-buffer "*Async Shell Command*")
        (kill-buffer "*Async Shell Command*"))))
#+END_SRC

*** String Edit
#+BEGIN_SRC emacs-lisp
  (use-package string-edit
    :ensure t)
#+END_SRC

*** Sudo Edit
#+BEGIN_SRC emacs-lisp
  (use-package sudo-edit
    :ensure t)
#+END_SRC

*** Tempo
#+BEGIN_SRC emacs-lisp
  (use-package tempo
    :init
    (add-to-list 'load-path "~/.emacs.d/tempo"))
#+END_SRC

*** Term
#+BEGIN_SRC emacs-lisp
  (use-package term
    :init
    (defun term-toggle-mode ()
      (interactive)
      (if (term-in-line-mode)
          (term-char-mode)
        (term-line-mode)))
    :config
    (setq-mode-local term-mode yas-dont-activate t))
#+END_SRC

*** Time
#+BEGIN_SRC emacs-lisp
  (use-package time
    :init
    (setq display-time-default-load-average nil)
    :config
    (display-time-mode 1))
#+END_SRC

*** Tiny
#+BEGIN_SRC emacs-lisp
  (use-package tiny
    :ensure t
    :bind* (("C-;" . tiny-expand)))
#+END_SRC

*** Toml Mode
#+BEGIN_SRC emacs-lisp
  (use-package toml-mode
    :ensure t)
#+END_SRC

*** Tramp
#+BEGIN_SRC emacs-lisp
  (use-package tramp
    :init
    (defun is-tramp-mode ()
      (file-remote-p default-directory))
    ;; Immediately reread remote directories
    (setq tramp-completion-reread-directory-timeout nil)
    ;; Set Tramp backup file location
    (setq tramp-backup-directory-alist backup-directory-alist))
#+END_SRC

*** Transpose Mark
#+BEGIN_SRC emacs-lisp
  (use-package transpose-mark
    :ensure t)
#+END_SRC

*** Twittering Mode
#+BEGIN_SRC emacs-lisp
  (use-package twittering-mode
    :ensure t
    :bind (:map twittering-mode-map
                ("s" . twittering-search)
                ("q" . previous-buffer)
                ("w" . delete-window))
    :init
    (defvar twittering-mode-map (make-sparse-keymap))
    (setq twittering-icon-mode t
          ;; Use master password for twitter instead of authenticating every time
          twittering-cert-file "/etc/ssl/certs/ca-bundle.crt"
          twittering-use-master-password t
          twittering-convert-fix-size 24)
    :config
    (add-hook* 'twittering-mode-hook (setq-local mode-line-format nil)))
#+END_SRC

*** Uuidgen
#+BEGIN_SRC emacs-lisp
  (use-package uuidgen
    :ensure t)
#+END_SRC

*** VC Hooks
#+BEGIN_SRC emacs-lisp
  (use-package vc-hooks
    :init
    ;; follow symlinks and don't ask
    (setq vc-follow-symlinks t)
    ;; Don't use version control for all files
    (setq vc-ignore-dir-regexp
          (format "\\(%s\\)\\|\\(%s\\)"
                  vc-ignore-dir-regexp
                  tramp-file-name-regexp)))
#+END_SRC

*** Vi Tilde Fringe
#+BEGIN_SRC emacs-lisp
  (use-package vi-tilde-fringe
    :ensure t
    :config
    (global-vi-tilde-fringe-mode 1))
#+END_SRC

*** Web Mode
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t
    :mode ("\\.dtl\\'"
           "\\.eex\\'"
           "\\.erb\\'"
           "\\.tpl\\'")
    :init
    (setq web-mode-markup-indent-offset 4
          web-mode-css-indent-offset 4
          web-mode-code-indent-offset 4))
#+END_SRC

*** Whitespace
#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :config
    (setq whitespace-style
          '(face tabs spaces trailing
                 space-before-tab indentation
                 space-after-tab space-mark tab-mark)))
#+END_SRC

*** Window Numbering
#+BEGIN_SRC emacs-lisp
  (use-package window-numbering
    :ensure t
    :config
    (window-numbering-mode t))
#+END_SRC

*** Winner
#+BEGIN_SRC emacs-lisp
  (use-package winner
    :init
    (setq winner-boring-buffers
          '("*Completions*"
            "*Compile-Log*"
            "*inferior-lisp*"
            "*Fuzzy Completions*"
            "*Apropos*"
            "*dvc-error*"
            "*Help*"
            "*cvs*"
            "*Buffer List*"
            "*Ibuffer*"))
    :config
    (winner-mode t))
#+END_SRC

*** Wrap Region
#+BEGIN_SRC emacs-lisp
  (use-package wrap-region
    :ensure t
    :config
    (wrap-region-global-mode))
#+END_SRC

*** WS Butler
#+BEGIN_SRC emacs-lisp
  (use-package ws-butler
    :ensure t
    :config
    (ws-butler-global-mode)
    ;; Disable aftersave
    (defun ws-butler-after-save ()))
#+END_SRC

*** Yaml Mode
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :ensure t)
#+END_SRC

*** Yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :config
    (yas-global-mode t)
    (add-hook 'prog-mode-hook 'yas-minor-mode)
    (setq-mode-local snippet-mode require-final-newline nil))
#+END_SRC

*** Zoom Window
#+BEGIN_SRC emacs-lisp
  (use-package zoom-window
    :ensure t
    :bind* ("C-x C-1" . zoom-window-zoom))
#+END_SRC

*** Spaceline
#+BEGIN_SRC emacs-lisp
  (use-package spaceline-config
    ;; Needs to be loaded last
    :ensure spaceline
    :init
    (setq powerline-default-separator 'bar
          spaceline-highlight-face-func 'spaceline-highlight-face-evil-state)
    :config
    (spaceline-spacemacs-theme)
    (spaceline-toggle-minor-modes-off)
    (spaceline-toggle-anzu-off))
#+END_SRC

*** Theme
#+BEGIN_SRC emacs-lisp
  (use-package darktooth-theme
    :ensure t
    :config
    (set-face-attribute 'default nil :foreground "#c6a57b"))
#+END_SRC

** Functions
*** Keyboard Functions
#+BEGIN_SRC emacs-lisp
  (defun tab-to-tab-stop-line-or-region (&optional left)
    (interactive)
    (let ((args) (function))
      (when (mark)
        (when (<  (mark) (point)) (setq args (list (mark)  (point))))
        (when (>= (mark) (point)) (setq args (list (point) (mark)))))
      (when (not left) (setq func 'indent-rigidly-right-to-tab-stop))
      (when left       (setq func 'indent-rigidly-left-to-tab-stop))
      (when (region-active-p)
        (apply func args)
        (activate-mark)
        (error "Region tab"))
      (unless (region-active-p)
        (tab-to-tab-stop))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun tab-to-tab-stop-line-or-region-backward (&optional left)
    (interactive)
    (tab-to-tab-stop-line-or-region t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun capitalize-previous-word ()
    (interactive)
    (save-excursion
      (backward-word)
      (capitalize-word 1)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun remove-newline-space ()
    (interactive)
    (cl-flet ((point-is-blank () (member (thing-at-point 'char t) '("\n" "\s"))))
      (unless (and (point-is-blank)
                   (equal (current-column) 0))
        (backward-char 1))
      (while (point-is-blank)
        (backward-char 1))
      (forward-char 1)
      (while (point-is-blank)
        (delete-char 1))
      (newline-and-indent)
      (unless (member major-mode '(scheme-mode))
        (newline-and-indent))))
#+END_SRC

*** Buffer
#+BEGIN_SRC emacs-lisp
  (defun switch-to-minibuffer ()
    "Switch to minibuffer window."
    (interactive)
    (if (active-minibuffer-window)
        (select-window (active-minibuffer-window))
      (error "Minibuffer is not active")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun kill-buffer-if-exists (buffer)
    "Attempt to kill BUFFER if it exists."
    (if (get-buffer buffer)
        (kill-buffer buffer)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun reset-buffer (buffer)
    (kill-buffer-if-exists buffer)
    (generate-new-buffer buffer))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun no-split ()
    (interactive)
    (setq-local split-width-threshold 2000)
    (setq-local split-height-threshold 2000))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun toggle-window-split ()
    (interactive)
    (if (= (count-windows) 2)
        (let* ((this-win-buffer (window-buffer))
               (next-win-buffer (window-buffer (next-window)))
               (this-win-edges (window-edges (selected-window)))
               (next-win-edges (window-edges (next-window)))
               (this-win-2nd (not (and (<= (car this-win-edges)
                                           (car next-win-edges))
                                       (<= (cadr this-win-edges)
                                           (cadr next-win-edges)))))
               (splitter
                (if (= (car this-win-edges)
                       (car (window-edges (next-window))))
                    'split-window-horizontally
                  'split-window-vertically)))
          (delete-other-windows)
          (let ((first-win (selected-window)))
            (funcall splitter)
            (if this-win-2nd (other-window 1))
            (set-window-buffer (selected-window) this-win-buffer)
            (set-window-buffer (next-window) next-win-buffer)
            (select-window first-win)
            (if this-win-2nd (other-window 1))))))
#+END_SRC

*** Frame
#+BEGIN_SRC emacs-lisp
  (defun frame-name (frame)
    (frame-parameter frame 'name))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun frame-exists (name)
    (member name (mapcar 'frame-name (frame-list))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun attic/setup-frames ()
    (interactive)
    (set-frame-name "Main")
    (select-frame-by-name "Main")
    (unless (-any 'elscreen-screen-live-p '(1 2 3 4 5))
      (elscreen-create-initial-5-screens))

    ;; Twitter Frame
    (unless (frame-exists "Twitter")
      (new-frame '((name . "Twitter"))))
    (select-frame-by-name "Twitter")
    (unless (get-buffer ":home")
      (twit))
    (elscreen-create-initial-5-screens)
    (switch-to-buffer ":home")

    ;; IRC Frame
    (unless (frame-exists "IRC")
      (new-frame '((name . "IRC"))))
    (select-frame-by-name "IRC")
    (elscreen-create-initial-5-screens)
    (let ((irc-buffer-exists (get-buffer "irc.freenode.net:6667")))
      (unless irc-buffer-exists
        (attic/erc))
      (elscreen-goto-2)
      (switch-to-buffer "irc.freenode.net:6667")
      (elscreen-goto-3)
      (switch-to-buffer "irc.freenode.net:6667")
      (elscreen-goto-4)
      (switch-to-buffer "irc.freenode.net:6667")
      (elscreen-goto-5)
      (switch-to-buffer "irc.freenode.net:6667")
      (elscreen-goto-1)
      (switch-to-buffer "irc.freenode.net:6667")))
#+END_SRC

*** Make
#+BEGIN_SRC emacs-lisp
  (defun cd-up-to-file (file)
    "Go up a directory until you find FILE or enter the root directory.
  If file is found then return t else nil."
    (while (not (or (file-exists-p file) (equal default-directory "/")))
      (cd ".."))
    (file-exists-p file))

  (defun run-make (arg name)
    (interactive)
    (reset-buffer "*Make Find Makefile*")
    (with-current-buffer "*Make Find Makefile*"
      (if (cd-up-to-file "Makefile")
          (progn
            (kill-buffer-if-exists name)
            (cond
             ((equal arg "start")
              (async-shell-command (concat "make " arg) name))
             (t
              (let ((comp-buffer (compile (concat "make " arg))))
                (with-current-buffer comp-buffer
                  (rename-buffer name))))))
        (message "Could not find Makefile"))))

  (defun attic/make-go ()
    (interactive)
    (run-make "go" "[Make go]"))

  (defun attic/make-restart ()
    (interactive)
    (run-make "restart" "[Make Restart]"))

  (defun attic/make-start ()
    (interactive)
    (run-make "start" "[Make Start]"))

  (defun attic/make-stop ()
    (interactive)
    (run-make "stop" "[Make Stop]"))

  (defun attic/make-test ()
    (interactive)
    (run-make "test" "[Make Test]"))

  (defun attic/make-default ()
    (interactive)
    (run-make "" "[Make]"))

  (defun attic/make-custom (input)
    "run make with user input."
    (interactive "sMake: ")
    (run-make input "[Custom Make]"))
#+END_SRC

** Hydras
*** Keys
Define the Hydra Space key
#+BEGIN_SRC emacs-lisp
  (define-key dired-mode-map           (kbd "<SPC>") 'attic-main/body)
  (define-key doc-view-mode-map        (kbd "<SPC>") 'attic-main/body)
  (define-key elfeed-search-mode-map   (kbd "<SPC>") 'attic-main/body)
  (define-key elfeed-show-mode-map     (kbd "<SPC>") 'attic-main/body)
  (define-key grep-mode-map            (kbd "<SPC>") 'attic-main/body)
  (define-key help-mode-map            (kbd "<SPC>") 'attic-main/body)
  (define-key magit-revision-mode-map  (kbd "<SPC>") 'attic-main/body)
  (define-key magit-status-mode-map    (kbd "<SPC>") 'attic-main/body)
  (define-key messages-buffer-mode-map (kbd "<SPC>") 'attic-main/body)
  (define-key mu4e-headers-mode-map    (kbd "<SPC>") 'attic-main/body)
  (define-key mu4e-main-mode-map       (kbd "<SPC>") 'attic-main/body)
  (define-key mu4e-view-mode-map       (kbd "<SPC>") 'attic-main/body)
  (define-key package-menu-mode-map    (kbd "<SPC>") 'attic-main/body)
  (define-key twittering-mode-map      (kbd "<SPC>") 'attic-main/body)
#+END_SRC

*** Main
#+BEGIN_SRC emacs-lisp
  (defhydra attic-main (:color blue :columns 7)
    "Attic"
    ("`" elscreen-toggle "Elscreen Toggle")
    ("RET" nil)
    ("'" helm-org-capture-templates nil)
    ("0" elscreen-goto-0 nil)
    ("1" elscreen-goto-1 nil)
    ("2" elscreen-goto-2 nil)
    ("3" elscreen-goto-3 nil)
    ("4" elscreen-goto-4 nil)
    ("5" elscreen-goto-5 nil)
    ("6" elscreen-goto-6 nil)
    ("7" elscreen-goto-7 nil)
    ("8" elscreen-goto-8 nil)
    ("9" elscreen-goto-9 nil)
    (";" helm-M-x nil)
    ("<SPC>" back-button-local-backward "Jump backward" :color red)
    ("C-<SPC>" back-button-local-forward "Jump forward" :color red)
    ("M-d" helm-swoop nil)
    ("s" async-shell-command "ASync Shell")
    ("b" helm-buffers-list "Buffers")
    ("d" helm-swoop "Swoop")
    ("f" attic-file/body "File")
    ("w" attic-window/body "Window")
    ("n" attic-mc/body "Multi Cursor")
    ("g" magit-status "Magit")
    ("i" remove-newline-space nil)
    ("j" evil-normal-state "Lock")
    ("k" kill-buffer "Kill")
    ("m" attic-emms/body "EMMS")
    ("q" attic-make/body "Make")
    ("a" attic-projectile/body "Projectile")
    ("h" attic-help/body "Help")
    ("x" helm-M-x "M-x")
    ("r" rgrep "RGrep")
    ("t" transpose-mark nil)
    ("c" attic-macro/body "Macro"))
#+END_SRC

*** Window
#+BEGIN_SRC emacs-lisp
  (defhydra attic-window (:color red :columns 4)
    "Attic Window"
    ("q" nil "Quit" :color blue)
    ("RET" nil :color blue)
    ("e" zoom-window-zoom "Zoom" :color blue)
    ("u" winner-undo "Winner Undo")
    ("U" winner-redo "Winner Redo")
    ("w" enlarge-window-horizontally "Enlarge Horizontally")
    ("s" shrink-window-horizontally "Shrink Horizontally")
    ("d" enlarge-window "Enlarge")
    ("a" shrink-window "Shrink")
    ("<tab>" toggle-window-split "Toggle")
    ("p" previous-buffer "Previous")
    ("t" elwm-transpose-window "Transpose")
    ("r" elwm-rotate-window "Rotate")
    ("/" elwm-split-window "Split")
    ("k" elwm-swap-up "Up")
    ("j" elwm-swap-down "Down")
    ("h" elwm-swap-left "Left")
    ("l" elwm-swap-right "Right")
    ("K" elwm-shift-up "Up")
    ("J" elwm-shift-down "Down")
    ("H" elwm-shift-left "Left")
    ("L" elwm-shift-right "Right"))
#+END_SRC

*** Multiple Cursors
#+BEGIN_SRC emacs-lisp
  (defhydra attic-mc (:color red :columns 4)
    "Attic MC"
    ("q" nil "Quit")
    ("e" attic-mc-edit/body "Edit" :color blue)
    ("l" attic-mc-like-this/body "Like this" :color blue)
    ("r" attic-mc-region/body "Region" :color blue)
    ("m" attic-mc-mmlte/body "Mmlte" :color blue)
    ("w" attic-mc-word/body "Word" :color blue)
    ("s" attic-mc-symbol/body "Symbol" :color blue)
    ("d" attic-mc-defun/body "Defun" :color blue)
    ("o" mc/mark-pop "mark-pop")
    ("@" mc/mark-all-dwim "mark-all-dwim")
    ("k" mc/keyboard-quit "keyboard-quit")
    ("f" mc/cycle-forward "cycle-forward")
    ("b" mc/cycle-backward "cycle-backward")
    ("va" mc/vertical-align "vertical-align")
    ("vs" mc/vertical-align-with-space "vertical-align-with-space")
    ("n" mc/mark-next-lines "mark-next-lines")
    ("p" mc/mark-previous-lines "mark-previous-lines")
    ("" mc/mark-sgml-tag-pair "mark-sgml-tag-pair")
    ("@" mc/mark-all-like-this "mark-all-like-this")
    ("n" mc/mark-next-like-this "mark-next-like-this")
    ("p" mc/mark-previous-like-this "mark-previous-like-this")
    ("N" mc/skip-to-next-like-this "skip-to-next-like-this")
    ("P" mc/skip-to-previous-like-this "skip-to-previous-like-this"))
#+END_SRC

*** Multiple Cursors Edit
#+BEGIN_SRC emacs-lisp
  (defhydra attic-mc-edit (:color red :columns 4)
    ("q" nil "Quit")
    ("<tab>" attic-mc/body "Back" :color blue)
    ("l" mc/edit-lines "edit-lines")
    ("b" mc/edit-beginnings-of-lines "edit-beginnings-of-lines")
    ("e" mc/edit-ends-of-lines "edit-ends-of-lines")
    ("i" mc/insert-numbers "insert-numbers"))
#+END_SRC

*** Multiple Cursors Like This
#+BEGIN_SRC emacs-lisp
  (defhydra attic-mc-like-this (:color red :columns 4)
    ("q" nil "Quit")
    ("<tab>" attic-mc/body "Back" :color blue)
    ("un" mc/unmark-next-like-this "unmark-next-like-this")
    ("d@" mc/mark-all-like-this-dwim "mark-all-like-this-dwim")
    ("up" mc/unmark-previous-like-this "unmark-previous-like-this")
    ("m" mc/mark-more-like-this-extended "mark-more-like-this-extended"))
#+END_SRC

*** Multiple Cursors Region
#+BEGIN_SRC emacs-lisp
  (defhydra attic-mc-region (:color red :columns 4)
    ("q" nil "Quit")
    ("<tab>" attic-mc/body "Back" :color blue)
    ("s" mc/sort-regions "sort-regions")
    ("r" mc/reverse-regions "reverse-regions")
    ("@" mc/mark-all-in-region "mark-all-in-region")
    ("x" mc/mark-all-in-region-regexp "mark-all-in-region-regexp"))
#+END_SRC

*** Multiple Cursors MMLTE
#+BEGIN_SRC emacs-lisp
  (defhydra attic-mc-mmlte (:color red :columns 4)
    ("q" nil "Quit")
    ("<tab>" attic-mc/body "Back" :color blue)
    ("k" mc/mmlte--up "mmlte--up")
    ("h" mc/mmlte--left "mmlte--left")
    ("j" mc/mmlte--down "mmlte--down")
    ("l" mc/mmlte--right "mmlte--right"))
#+END_SRC

*** Multiple Cursors Word
#+BEGIN_SRC emacs-lisp
  (defhydra attic-mc-word (:color red :columns 4)
    ("q" nil "Quit")
    ("<tab>" attic-mc/body "Back" :color blue)
    ("n" mc/mark-next-word-like-this "mark-next-word-like-this")
    ("@" mc/mark-all-words-like-this "mark-all-words-like-this")
    ("p" mc/mark-previous-word-like-this "mark-previous-word-like-this"))
#+END_SRC

*** Multiple Cursors Symbol
#+BEGIN_SRC emacs-lisp
  (defhydra attic-mc-symbol (:color red :columns 4)
    ("q" nil "Quit")
    ("<tab>" attic-mc/body "Back" :color blue)
    ("n" mc/mark-next-symbol-like-this "mark-next-symbol-like-this")
    ("p" mc/mark-previous-symbol-like-this "mark-previous-symbol-like-this")
    ("@" mc/mark-all-symbols-like-this "mark-all-symbols-like-this"))
#+END_SRC

*** Multiple Cursors Defun
#+BEGIN_SRC emacs-lisp
  (defhydra attic-mc-defun (:color red :columns 4)
    ("t" mc/mark-all-like-this-in-defun "mark-all-like-this-in-defun")
    ("s" mc/mark-all-symbols-like-this-in-defun "mark-all-symbols-like-this-in-defun")
    ("w" mc/mark-all-words-like-this-in-defun "mark-all-words-like-this-in-defun"))
#+END_SRC

*** Macro
#+BEGIN_SRC emacs-lisp
  (defhydra attic-macro (:color blue :columns 4)
    "Attic Macro"
    ("s"    kmacro-start-macro "kmacro-start-macro")
    ("k"    kmacro-end-or-call-macro-repeat "kmacro-end-or-call-macro-repeat")
    ("r"    apply-macro-to-region-lines "apply-macro-to-region-lines")
    ("q"    kbd-macro-query "kbd-macro-query")
    ("C-n"  kmacro-cycle-ring-next "kmacro-cycle-ring-next")
    ("C-p"  kmacro-cycle-ring-previous "kmacro-cycle-ring-previous")
    ("C-v"  kmacro-view-macro-repeat "kmacro-view-macro-repeat")
    ("C-d"  kmacro-delete-ring-head "kmacro-delete-ring-head")
    ("C-t"  kmacro-swap-ring "kmacro-swap-ring")
    ("C-l"  kmacro-call-ring-2nd-repeat "kmacro-call-ring-2nd-repeat")
    ("C-f"  kmacro-set-format "kmacro-set-format")
    ("C-c"  kmacro-set-counter "kmacro-set-counter")
    ("C-i"  kmacro-insert-counter "kmacro-insert-counter")
    ("C-a"  kmacro-add-counter "kmacro-add-counter")
    ("C-e"  kmacro-edit-macro-repeat "kmacro-edit-macro-repeat")
    ("r"    kmacro-edit-macro "kmacro-edit-macro")
    ("e"    edit-kbd-macro "edit-kbd-macro")
    ("l"    kmacro-edit-lossage "kmacro-edit-lossage")
    (" "    kmacro-step-edit-macro "kmacro-step-edit-macro")
    ("b"    kmacro-bind-to-key "kmacro-bind-to-key")
    ("n"    kmacro-name-last-macro "kmacro-name-last-macro")
    ("x"    kmacro-to-register "kmacro-to-register"))
#+END_SRC

*** Make
#+BEGIN_SRC emacs-lisp
  (defhydra attic-make (:color blue :columns 2)
    "[Make]"
    ("p" attic/make-stop    "Stop")
    ("r" attic/make-restart "Restart")
    ("s" attic/make-start   "Start")
    ("t" attic/make-test    "Test")
    ("o" attic/make-go      "Go")
    ("q" attic/make-default "Make")
    ("c" attic/make-custom  "Custom"))
#+END_SRC

*** File
#+BEGIN_SRC emacs-lisp
  (defhydra attic-file (:color blue :columns 2)
    "Attic File"
    ("f" helm-find-files "helm-find-files")
    ("b" helm-bookmarks "helm-bookmarks")
    ("j" helm-buffers-list "helm-buffers-list")
    ("h" previous-buffer "previous-buffer" :color red)
    ("l" next-buffer "next-buffer" :color red))
#+END_SRC

*** Projectile
#+BEGIN_SRC emacs-lisp
  (defhydra attic-projectile (:color blue :columns 2)
    "Helm Projectile"
    ("a" helm-projectile "helm-projectile")
    ("b" helm-projectile-switch-to-buffer "helm-projectile-switch-to-buffer")
    ("c" helm-projectile-ack "helm-projectile-ack")
    ("d" helm-projectile-find-dir "helm-projectile-find-dir")
    ("e" helm-projectile-switch-to-eshell "helm-projectile-switch-to-eshell")
    ("s" helm-projectile-find-file "helm-projectile-find-file")
    ("g" helm-projectile-grep "helm-projectile-grep")
    ("i" helm-projectile-find-files-eshell-command-on-file-action "helm-projectile-find-files-eshell-command-on-file-action")
    ("k" helm-projectile-find-file-in-known-projects "helm-projectile-find-file-in-known-projects")
    ("o" helm-projectile-find-other-file "helm-projectile-find-other-file")
    ("r" helm-projectile-recentf "helm-projectile-recentf")
    ("f" helm-projectile-switch-project "helm-projectile-switch-project")
    ("t" projectile-run-term "term")
    ("w" helm-projectile-find-file-dwim "helm-projectile-find-file-dwim"))
#+END_SRC

*** Help
#+BEGIN_SRC emacs-lisp
  (defhydra attic-help (:color blue :columns 2)
    "Helm Help"
    ("g" helm-geiser "helm-geiser"))
#+END_SRC
